var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = ExprTools","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"splitdef\ncombinedef\nsignature","category":"page"},{"location":"api/#ExprTools.splitdef","page":"API","title":"ExprTools.splitdef","text":"splitdef(ex::Expr; throw::Bool=true) -> Union{Dict{Symbol,Any}, Nothing}\n\nSplit a function definition expression into its various components including:\n\n:head: Expression head of the function definition (:function, :(=), :(->))\n:name: Name of the function (not present for anonymous functions)\n:params: Parametric types defined on constructors\n:args: Positional arguments of the function\n:kwargs: Keyword arguments of the function\n:rtype: Return type of the function\n:whereparams: Where parameters\n:body: Function body (not present for empty functions)\n\nAll components listed may not be present in the returned dictionary with the exception of :head which will always be present.\n\nIf the provided expression is not a function then an exception will be raised when throw=true. Use throw=false avoid raising an exception and return nothing instead.\n\nSee also: combinedef\n\n\n\n\n\n","category":"function"},{"location":"api/#ExprTools.combinedef","page":"API","title":"ExprTools.combinedef","text":"combinedef(def::Dict{Symbol,Any}) -> Expr\n\nCreate a function definition expression from various components. Typically used to construct a function using the result of splitdef.\n\nIf def[:head] is not provided it will default to :function.\n\nFor more details see the documentation on splitdef.\n\n\n\n\n\n","category":"function"},{"location":"api/#ExprTools.signature","page":"API","title":"ExprTools.signature","text":"signature(m::Method) -> Dict{Symbol,Any}\n\nFinds the expression for a method's signature as broken up into its various components including:\n\n:name: Name of the function\n:params: Parametric types defined on constructors\n:args: Positional arguments of the function\n:whereparams: Where parameters\n\nAll components listed above may not be present in the returned dictionary if they are not in the function definition.\n\nLimited support for:\n\n:kwargs: Keyword arguments of the function. Only the names will be included, not the default values or type constraints.\n\nUnsupported:\n\n:rtype: Return type of the function\n:body: Function body0\n:head: Expression head of the function definition (:function, :(=), :(->))\n\nFor more complete coverage, consider using splitdef with CodeTracking.definition.\n\nThe dictionary of components returned by signature match those returned by splitdef and include all that are required by combinedef, except for the :body component.\n\nkeywords\n\nextra_hygiene=false: if set to true this forces name-hygiene on the TypeVars in  UnionAlls, regenerating each with a unique name via gensym. This shouldn't actually be required as they are scoped such that they are not supposed to leak. However, there is a long-standing julia bug that means  they do leak if they clash with function type-vars.\n\n\n\n\n\nsignature(sig::Type{<:Tuple})\n\nLike ExprTools.signature(::Method) but on the underlying signature type-tuple, rather than the Method. Forsigbeing a tuple-type representing a methods type signature, this generates a dictionary that can be passes toExprTools.combinedefto define that function, Provided that you assign the:body` key on the dictionary first.\n\nThe quality of the output, in terms of matching names etc is not as high as for the signature(::Method), but all the key information is present; and the type-tuple is for other purposes generally easier to manipulate.\n\nExamples\n\njulia> signature(Tuple{typeof(identity), Any})\nDict{Symbol, Any} with 2 entries:\n  :name => :(op::typeof(identity))\n  :args => Expr[:(x1::Any)]\n\njulia> signature(Tuple{typeof(+), Vector{T}, Vector{T}} where T<:Number)\nDict{Symbol, Any} with 3 entries:\n  :name        => :(op::typeof(+))\n  :args        => Expr[:(x1::Array{var\"##T#5492\", 1}), :(x2::Array{var\"##T#5492\", 1})]\n  :whereparams => Any[:(var\"##T#5492\" <: Number)]\n\nkeywords\n\nextra_hygiene=false: if set to true this forces name-hygine on the TypeVars in  UnionAlls, regenerating each with a unique name via gensym. This shouldn't actually be required as they are scoped such that they are not supposed to leak. However, there is a long-standing julia bug that means  they do leak if they clash with function type-vars.\n\n\n\n\n\n","category":"function"},{"location":"#ExprTools","page":"Home","title":"ExprTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExprTools provides tooling for working with Julia expressions during metaprogramming. This package aims to provide light-weight performant tooling without requiring additional package dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively see the MacroTools package for more powerful set of tools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ExprTools provides tooling for working with Julia expressions during metaprogramming. This package aims to provide light-weight performant tooling without requiring additional package dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively see the MacroTools package for more powerful set of tools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, this package provides the splitdef, signature and combinedef functions which are useful for inspecting and manipulating function definition expressions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"splitdef works on a function definition expression and returns a Dict of its parts.\ncombinedef takes Dict from splitdef and builds it into an expression.\nsignature works on a Method returning a similar Dict that holds the parts of the expressions that would form its signature.","category":"page"},{"location":"","page":"Home","title":"Home","text":"e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ExprTools\n\njulia> ex = :(\n           function Base.f(x::T, y::T) where T\n               x + y\n           end\n       )\n:(function Base.f(x::T, y::T) where T\n      #= none:3 =#\n      x + y\n  end)\n\njulia> def = splitdef(ex)\nDict{Symbol,Any} with 5 entries:\n  :args        => Any[:(x::T), :(y::T)]\n  :body        => quoteâ€¦\n  :name        => :(Base.f)\n  :head        => :function\n  :whereparams => Any[:T]\n\njulia> def[:name] = :g;\n\njulia> def[:head] = :(=);\n\njulia> def[:body] = :(x * y);\n\njulia> g_expr = combinedef(def)\n:((g(x::T, y::T) where T) = x * y)\n\njulia> eval(g_expr)\ng (generic function with 1 method)\n\njulia> g_method = first(methods(g))\ng(x::T, y::T) where T in Main\n\njulia> signature(g_method)\nDict{Symbol,Any} with 3 entries:\n  :name        => :g\n  :args        => Expr[:(x::T), :(y::T)]\n  :whereparams => Any[:T]","category":"page"}]
}
